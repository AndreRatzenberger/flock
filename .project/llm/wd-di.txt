# Repository Analysis

## Repository Statistics

- **Extensions analyzed**: .md, .py
- **Number of files analyzed**: 29
- **Total lines of code (approx)**: 2942

## Project Files

### 1. README.md

- **File ID**: file_0
- **Type**: File
- **Line Count**: 402
- **Description**: File at README.md

**Content**:
```
# WD-DI: .NET Style Dependency Injection for Python

WD-DI is a lightweight dependency injection library for Python inspired by .NET's DI system. It provides a robust and flexible way to manage dependencies and lifetimes in your applications. For the python purists: WD-DI needs no external libraries, just python std libraries.

Check this README.md for an overview of patterns supported by WD-DI.

[design_tutorial.md](./docs/design_tutorial.md) should provide some material for beginners on how to use DI to have a real positive impact on your software

[todo_until_feature_complete.md](./docs/todo_until_feature_complete.md) lists todos needed to be done to be feature congruent to .NET


---

## Features

WD-DI supports a variety of dependency injection patterns and configurations, including service lifetimes, constructor injection, configuration binding, middleware pipelines, and advanced lifetime management. Each feature comes with clear examples and guidance.

---

### 1. Service Lifetimes

**What is it?**  
Service lifetimes define how instances of services are created and shared. WD-DI supports three lifetimes:

- **Transient:** A new instance is created every time the service is requested.
- **Singleton:** A single instance is created and shared across the entire application.
- **Scoped:** A single instance is created for a specific scope (e.g., per web request).

**Example:**

```python
from wd.di import services

# Register services with explicit implementation types:
services.add_transient(IService, ServiceImpl)   # Transient service
services.add_singleton(IService, ServiceImpl)   # Singleton service
services.add_scoped(IService, ServiceImpl)      # Scoped service

# Register service as self-implementing:
services.add_singleton(ServiceImpl)

# Using decorators for cleaner registration:
from wd.di.decorators import singleton, transient, scoped

@singleton()
class MyService:
    def do_something(self):
        pass

@transient()
class PerRequestService:
    def do_something(self):
        pass

@scoped()
class ScopedService:
    def do_something(self):
        pass
```

**When to use:**  
- Use **Transient** for lightweight, stateless services.
- Use **Singleton** for services that should be shared and reused.
- Use **Scoped** for services tied to a specific context, such as a web request.

---

### 2. Dependency Injection (Constructor Injection)

**What is it?**  
WD-DI uses constructor injection to automatically resolve and inject dependencies into your services. This promotes clear, testable, and maintainable code.

**Example:**

```python
@singleton()
class UserService:
    def __init__(self, db_service: DatabaseService):
        self.db = db_service

    def get_user(self, user_id: str):
        return self.db.query(f"SELECT * FROM users WHERE id = {user_id}")

# Build the service provider and resolve services:
provider = services.build_service_provider()
user_service = provider.get_service(UserService)

# with working code completion and resolved type for everything get_service returns!
# see examples/type_hints_example.py
```

**When to use:**  
Always prefer constructor injection—it makes dependencies explicit and simplifies unit testing.

---

### 3. Configuration and Options Pattern

**What is it?**  
WD-DI provides a configuration system that binds configuration data to strongly-typed options classes. This pattern helps centralize configuration logic and provides type safety.

**Example:**

```python
from dataclasses import dataclass
from wd.di import services
from wd.di.config import Configuration, Options

# Define an options class for your configuration
@dataclass
class DatabaseOptions:
    connection_string: str = ""
    max_connections: int = 10

# Create configuration from a dictionary (or JSON/environment variables)
config = Configuration({
    "database": {
        "connectionString": "mysql://localhost:3306/mydb",
        "maxConnections": 100
    }
})

# Register the configuration service
services.add_singleton_factory(IConfiguration, lambda _: config)

# Bind the configuration to strongly-typed options
services.configure(DatabaseOptions, section="database")

# Use the options in your service
@singleton()
class DatabaseService:
    def __init__(self, options: Options[DatabaseOptions]):
        self.connection_string = options.value.connection_string
        self.max_connections = options.value.max_connections
```

**When to use:**  
Use strongly-typed options to manage application settings and configurations in a clean, centralized way.

---

### 4. Middleware Pipeline

**What is it?**  
The middleware pipeline allows you to compose processing logic in a sequence. This is ideal for cross-cutting concerns such as logging, authentication, validation, caching, and error handling.

**Example:**

```python
from wd.di import services
from wd.di.middleware import IMiddleware, LoggingMiddleware, ValidationMiddleware

# Create custom middleware
class AuthMiddleware(IMiddleware):
    async def invoke(self, context, next):
        if not context.is_authenticated:
            raise ValueError("Not authenticated")
        return await next()

# Configure the middleware pipeline using a builder pattern:
app = services.create_application_builder()
app.configure_middleware(lambda builder: (
    builder
    .use_middleware(LoggingMiddleware)
    .use_middleware(AuthMiddleware)
    .use_middleware(ValidationMiddleware)
))

# Build the service provider and get the middleware pipeline:
provider = app.build()
pipeline = provider.get_service(MiddlewarePipeline)

# Execute the pipeline with a context object
result = await pipeline.execute(context)
```

**Built-in Middleware Components:**

- **LoggingMiddleware:** Logs pipeline execution.
- **ExceptionHandlerMiddleware:** Centralizes error handling.
- **ValidationMiddleware:** Validates the context.
- **CachingMiddleware:** Caches pipeline responses.

**When to use:**  
Use middleware pipelines to decouple and modularize cross-cutting concerns in your processing flows.

---

### 5. Scoped Services

**What is it?**  
Scoped services live only within a defined scope (e.g., a web request). WD-DI enforces explicit scope creation for such services and automatically disposes them when the scope ends.

**Example:**

```python
provider = services.build_service_provider()

# Create a new scope
with provider.create_scope() as scope:
    scoped_service = scope.get_service(MyService)
    # Use the scoped service here
```

**When to use:**  
Use scoped services when you need to manage the lifetime of resources such as database connections or transaction contexts, ensuring proper cleanup at the end of the scope.

---

## Advanced Features

WD-DI also includes several advanced patterns that further extend its capabilities:

### Instance Registration

**What is it?**  
Register pre-created objects with the DI container. This is useful for sharing externally configured or created instances (like loggers or configuration objects).

**Example:**

```python
class MyLogger:
    def log(self, msg):
        print(msg)

# Create and register an instance
logger_instance = MyLogger()
services.add_instance(MyLogger, logger_instance)

# Resolve and use the instance later:
provider = services.build_service_provider()
logger = provider.get_service(MyLogger)
assert logger is logger_instance  # True
logger.log("Instance registration works!")
```

**When to use:**  
Use instance registration when you need to inject a pre-configured or externally managed instance into your application.

---

### Circular Dependency Detection

**What is it?**  
Circular dependency detection safeguards your container against infinite recursion by detecting cycles in the dependency graph and raising a clear exception.

**Example:**

```python
# Define services with a circular dependency
class ServiceA:
    def __init__(self, service_b: "ServiceB"):
        self.service_b = service_b

class ServiceB:
    def __init__(self, service_a: ServiceA):
        self.service_a = service_a

services.add_transient(ServiceA)
services.add_transient(ServiceB)

provider = services.build_service_provider()

try:
    provider.get_service(ServiceA)
except Exception as e:
    print(e)  # Output includes: "Circular dependency detected for service: ..."
```

**When to use:**  
This feature works automatically. It’s essential for catching configuration errors early during development when your dependency graph inadvertently contains cycles.

---

### Explicit Scoped Services Management

**What is it?**  
WD-DI enforces explicit scope creation and automatically disposes scoped services at the end of the scope. This ensures that resources are cleaned up properly.

**Example:**

```python
# Define a disposable service
class DisposableResource:
    def __init__(self):
        self.disposed = False

    def dispose(self):
        self.disposed = True

services.add_scoped(DisposableResource)
provider = services.build_service_provider()

# Create a new scope and resolve a scoped service:
with provider.create_scope() as scope:
    resource = scope.get_service(DisposableResource)
    print(resource.disposed)  # False; resource is active

# After the scope, the resource is automatically disposed:
print(resource.disposed)  # True; dispose() was called
```

**When to use:**  
Scoped management is ideal when your services hold resources that need cleanup, such as file handles, database connections, or network sockets.

---

## Best Practices

1. **Constructor Injection:**  
   Always prefer constructor injection to clearly state dependencies and improve testability.

2. **Interface Segregation:**  
   Register services against interfaces to allow flexible swapping and better test isolation.

3. **Strongly-Typed Configuration:**  
   Use strongly-typed options for configuration to reduce runtime errors and centralize settings management.

4. **Middleware Separation:**  
   Keep middleware focused on a single responsibility to ensure composability and maintainability.

---

## Example Application

Below is a complete example that demonstrates how to set up and use WD-DI in a simple application:

```python
from dataclasses import dataclass
from wd.di import services
from wd.di.config import Configuration, Options

# Define interfaces
class IUserRepository:
    def get_user(self, user_id: str): pass

class IEmailService:
    def send_email(self, to: str, subject: str, body: str): pass

# Define configuration for email
@dataclass
class EmailOptions:
    smtp_server: str = ""
    port: int = 587
    username: str = ""
    password: str = ""

# Implement services
@singleton()
class UserRepository(IUserRepository):
    def get_user(self, user_id: str):
        return {"id": user_id, "name": "John Doe", "email": "john@example.com"}

@singleton()
class EmailService(IEmailService):
    def __init__(self, options: Options[EmailOptions]):
        self.options = options.value

    def send_email(self, to: str, subject: str, body: str):
        print(f"Sending email via {self.options.smtp_server}")
        # Email sending logic here

@singleton()
class UserService:
    def __init__(self, repository: IUserRepository, email_service: IEmailService):
        self.repository = repository
        self.email_service = email_service

    def notify_user(self, user_id: str, message: str):
        user = self.repository.get_user(user_id)
        self.email_service.send_email(
            to=user["email"],
            subject="Notification",
            body=message
        )

# Configure services and options
config = Configuration({
    "email": {
        "smtpServer": "smtp.gmail.com",
        "port": 587,
        "username": "myapp@gmail.com",
        "password": "secret"
    }
})

services.add_singleton_factory(IConfiguration, lambda _: config)
services.configure(EmailOptions, section="email")

services.add_singleton(IUserRepository, UserRepository)
services.add_singleton(IEmailService, EmailService)

# Build and use the service provider
provider = services.build_service_provider()
user_service = provider.get_service(UserService)
user_service.notify_user("123", "Hello, welcome to WD-DI!")
```


## License

This project is licensed under the terms of the LICENSE file included in the repository.
```

---

### 2. docs\design_tutorial.md

- **File ID**: file_1
- **Type**: File
- **Line Count**: 898
- **Description**: File at docs\design_tutorial.md

**Content**:
```
# Design Guide and Tutorial

Looking at numerous Python repositories, one thing is clear: the gap between good and terrible code is more pronounced in Python than in any other language. In no other language will you find highly-downloaded libraries with such questionable software design decisions and architecture.

Python is a flexible language, and everyone should embrace this flexibility. However, flexibility should not be an excuse for avoiding clean and structured architecture, because there comes a point in every developer's life when they become overwhelmed by their own library and the past decisions they made.

This is an attempt to increase awareness of dependency injection - specifically the way we prefer to use it (the .NET style) and how we implement it when building real software. Dependency injection is an often neglected topic, which is reason enough for us to show you the amazing things it enables you to do.

WD-DI isn't just a tool for resolving dependencies—it's a foundation for designing well-structured applications. Follow these guidelines and examples to leverage dependency injection in your project.

The first part explains the theory behind the DI pattern, while the second part implements a small application built on these principles!

By following this design guide, you can use WD-DI as the backbone for a well-architected, modular, and testable software system. Embrace dependency injection to:

- **Decouple components** using constructor injection.
- **Implement interface-driven design** for flexible, swappable components.
- **Centralize cross-cutting concerns** with a middleware pipeline.
- **Manage configurations** via strongly-typed options.
- **Enhance testability** by isolating dependencies and using mocks.
- **Build layered architectures** that scale and evolve gracefully.

This guide, with its accompanying code examples, provides a roadmap for integrating WD-DI into your projects, ensuring that your architecture remains robust, maintainable, and adaptable over time.

## Design Guide: Architecting Your Software with WD-DI

### 1. Separation of Concerns

**Principle:**  
Break your application into components with clear responsibilities. Use constructor injection to make dependencies explicit and decouple components.

**Example:**

```python
# EmailService: A service responsible for sending emails
class EmailService:
    def send_email(self, recipient: str, subject: str, body: str):
        print(f"Sending email to {recipient}")

# UserService: Depends on EmailService for notifications
@singleton()
class UserService:
    def __init__(self, email_service: EmailService):
        self.email_service = email_service

    def notify(self, user_id: str, message: str):
        # In a real app, fetch user's email from a repository, etc.
        self.email_service.send_email("user@example.com", "Notification", message)

# Register and use the services:
services.add_singleton(EmailService)
services.add_singleton(UserService)

provider = services.build_service_provider()
user_service = provider.get_service(UserService)
user_service.notify("123", "Your order has shipped!")
```

**When to use:**  
Apply separation of concerns to keep business logic distinct from infrastructure (e.g., sending emails, logging), making your code easier to maintain and test.

---

### 2. Component-Based Design

**Interface-Driven Development**

**Principle:**  
Define interfaces (or abstract base classes) and register implementations against these interfaces. This allows you to swap implementations and write cleaner tests.

**Example:**

```python
from abc import ABC, abstractmethod

# Define an interface for user repository
class IUserRepository(ABC):
    @abstractmethod
    def get_user(self, user_id: str):
        pass

# Implementation of the repository interface
@singleton()
class UserRepository(IUserRepository):
    def get_user(self, user_id: str):
        return {"id": user_id, "name": "John Doe"}

# Register the interface and its implementation:
services.add_singleton(IUserRepository, UserRepository)
```

**Lifetimes Matter**

**Principle:**  
Select service lifetimes based on the nature of the dependency:
- **Transient:** New instance per request.
- **Singleton:** One instance for the entire application.
- **Scoped:** One instance per defined scope (e.g., per web request).

**Example:**

```python
# Transient: A new instance is created each time
services.add_transient(IService, ServiceImpl)

# Singleton: One instance is shared application-wide
services.add_singleton(IService, ServiceImpl)

# Scoped: One instance per explicit scope
services.add_scoped(IService, ServiceImpl)
```

**When to use:**  
Use interface-driven design to enhance flexibility and testing. Choose lifetimes based on resource usage and desired sharing.

---

### 3. Middleware for Cross-Cutting Concerns

**Principle:**  
Centralize and modularize common tasks (logging, authentication, error handling) using a middleware pipeline.

**Example:**

```python
from wd.di.middleware import IMiddleware

# A simple logging middleware that wraps request processing
class LoggingMiddleware(IMiddleware):
    async def invoke(self, context, next):
        print("Request started")
        result = await next()
        print("Request finished")
        return result

# Configure the middleware pipeline:
app = services.create_application_builder()
app.configure_middleware(lambda builder: (
    builder.use_middleware(LoggingMiddleware)
))
provider = app.build()
pipeline = provider.get_service(MiddlewarePipeline)

# Simulated context for demonstration:
class DummyContext:
    is_authenticated = True

import asyncio
async def run_pipeline():
    result = await pipeline.execute(DummyContext())
    return result

asyncio.run(run_pipeline())
```

**When to use:**  
Utilize middleware for tasks that apply to many or all requests, ensuring consistency and reducing redundancy.

---

### 4. Robust Configuration Management

**Principle:**  
Centralize configuration using strongly-typed options. This provides compile-time checks and clearer configuration structures.

**Example:**

```python
from dataclasses import dataclass
from wd.di.config import Configuration, Options

@dataclass
class AppConfig:
    debug: bool = False
    api_key: str = ""

# Create and register configuration
config = Configuration({
    "app": {
        "debug": True,
        "apiKey": "secret-key"
    }
})

services.add_singleton_factory(IConfiguration, lambda _: config)
services.configure(AppConfig, section="app")

# Example service that uses configuration:
@singleton()
class AppService:
    def __init__(self, options: Options[AppConfig]):
        self.config = options.value

    def run(self):
        if self.config.debug:
            print("Running in debug mode")
        else:
            print("Running in production mode")

provider = services.build_service_provider()
app_service = provider.get_service(AppService)
app_service.run()
```

**When to use:**  
Adopt strongly-typed configuration to centralize and validate settings, reducing errors and simplifying environment-specific configuration.

---

### 5. Enhancing Testability and Maintainability

**Principle:**  
Using DI improves testability by allowing easy injection of mocks or stubs. Constructor injection makes dependencies explicit and testing straightforward.

**Example:**

```python
# A mock version of EmailService for testing purposes
class MockEmailService:
    def send_email(self, recipient, subject, body):
        print("Mock email sent")

# Testing UserService with a mock dependency:
def test_user_service():
    # Inject the mock email service directly
    user_service = UserService(email_service=MockEmailService())
    user_service.notify("123", "Test Message")

test_user_service()
```

**When to use:**  
Enhance testability by isolating components and substituting real implementations with mocks during unit tests.

---

### 6. Evolving Architecture with WD-DI

**Layered Application Architecture**

**Principle:**  
Structure your application into layers (Domain, Data Access, Presentation, Infrastructure) and use DI to manage dependencies between layers.

**Example:**

**Domain Layer:**

```python
from abc import ABC, abstractmethod

class IOrderService(ABC):
    @abstractmethod
    def process_order(self, order_id: str):
        pass

@singleton()
class OrderService(IOrderService):
    def process_order(self, order_id: str):
        print(f"Processing order {order_id}")
```

**Data Access Layer:**

```python
class IOrderRepository(ABC):
    @abstractmethod
    def get_order(self, order_id: str):
        pass

@singleton()
class OrderRepository(IOrderRepository):
    def get_order(self, order_id: str):
        return {"id": order_id, "item": "Book"}
```

**Presentation Layer:**

```python
@transient()
class OrderController:
    def __init__(self, order_service: IOrderService):
        self.order_service = order_service

    def handle_order(self, order_id: str):
        self.order_service.process_order(order_id)
```

**Infrastructure Layer:**

```python
# External logging service via instance registration
class Logger:
    def log(self, msg: str):
        print(f"LOG: {msg}")

logger_instance = Logger()
services.add_instance(Logger, logger_instance)
```

**Assembling the Application:**

```python
# Register layers with the DI container:
services.add_singleton(IOrderService, OrderService)
services.add_singleton(IOrderRepository, OrderRepository)
services.add_transient(OrderController)

provider = services.build_service_provider()
controller = provider.get_service(OrderController)
controller.handle_order("order123")
```

**When to use:**  
Build a layered architecture using WD-DI to cleanly separate business logic, data access, presentation, and infrastructure concerns. This enhances maintainability and scalability.

---

### 7. Practical Advice for Evolving Architectures

**Start Simple, Then Expand**

**Principle:**  
Begin with a minimal DI setup. As your project grows, add more sophisticated registration, resolution, and middleware configurations.

**Example:**

```python
# Start by registering core services:
services.add_singleton(DatabaseService)
services.add_singleton(UserService)

# Later, as the project evolves, integrate additional layers and middleware:
app = services.create_application_builder()
app.configure_middleware(lambda builder: (
    builder.use_middleware(LoggingMiddleware)
))
```

**When to use:**  
Adopt an incremental approach. Begin with essential services and progressively integrate advanced patterns like middleware pipelines, dynamic configuration, and custom lifetime management.



### 8. Common Python Anti-Patterns and DI Solutions

**Principle:**  
Python's flexibility, while powerful, can lead to common architectural pitfalls. Using dependency injection helps avoid these anti-patterns and promotes maintainable code.

#### Global State and Singletons

**Anti-Pattern:**
```python
# global_config.py
class GlobalConfig:
    _instance = None
    
    @classmethod
    def get_instance(cls):
        if cls._instance is None:
            cls._instance = cls()
        return cls._instance
    
    def __init__(self):
        self.api_key = "secret"
        self.debug = True

# Used everywhere in the codebase:
config = GlobalConfig.get_instance()
```

**DI Solution:**
```python
from dataclasses import dataclass
from wd.di.config import Configuration, Options

@dataclass
class AppConfig:
    api_key: str
    debug: bool

@singleton()
class ConfiguredService:
    def __init__(self, options: Options[AppConfig]):
        self.config = options.value
    
    def do_something(self):
        if self.config.debug:
            print("Debug mode")

# Register in your DI container
services.configure(AppConfig, section="app")
services.add_singleton(ConfiguredService)
```

#### Hidden Dependencies and Import-Time Side Effects

**Anti-Pattern:**
```python
# database.py
import sqlite3

# Global connection created at import time
db = sqlite3.connect("app.db")

class UserRepository:
    def get_user(self, user_id):
        cursor = db.cursor()
        cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))
        return cursor.fetchone()

# Used elsewhere:
repo = UserRepository()
user = repo.get_user(123)
```

**DI Solution:**
```python
from abc import ABC, abstractmethod
import sqlite3

class IDatabase(ABC):
    @abstractmethod
    def execute(self, query: str, params: tuple):
        pass

@singleton()
class Database(IDatabase):
    def __init__(self, connection_string: str):
        self.connection = sqlite3.connect(connection_string)
    
    def execute(self, query: str, params: tuple):
        cursor = self.connection.cursor()
        return cursor.execute(query, params)

@singleton()
class UserRepository:
    def __init__(self, db: IDatabase):
        self.db = db
    
    def get_user(self, user_id):
        return self.db.execute("SELECT * FROM users WHERE id = ?", (user_id,))

# Register with DI:
services.add_singleton(IDatabase, Database, connection_string="app.db")
services.add_singleton(UserRepository)
```

#### Module-Level Logic and Circular Dependencies

**Anti-Pattern:**
```python
# user_service.py
from order_service import get_user_orders

def get_user_details(user_id):
    orders = get_user_orders(user_id)
    return {"id": user_id, "orders": orders}

# order_service.py
from user_service import get_user_details

def get_user_orders(user_id):
    user = get_user_details(user_id)  # Circular dependency!
    return [{"order_id": 1}]
```

**DI Solution:**
```python
from abc import ABC, abstractmethod

class IOrderService(ABC):
    @abstractmethod
    def get_user_orders(self, user_id: str) -> list:
        pass

class IUserService(ABC):
    @abstractmethod
    def get_user_details(self, user_id: str) -> dict:
        pass

@singleton()
class OrderService(IOrderService):
    def get_user_orders(self, user_id: str) -> list:
        return [{"order_id": 1}]

@singleton()
class UserService(IUserService):
    def __init__(self, order_service: IOrderService):
        self.order_service = order_service
    
    def get_user_details(self, user_id: str) -> dict:
        orders = self.order_service.get_user_orders(user_id)
        return {"id": user_id, "orders": orders}

# Register with DI:
services.add_singleton(IOrderService, OrderService)
services.add_singleton(IUserService, UserService)
```

#### Monolithic Classes with Mixed Responsibilities

**Anti-Pattern:**
```python
class UserManager:
    def __init__(self):
        self.db = sqlite3.connect("app.db")
        self.logger = logging.getLogger()
        self.mailer = smtplib.SMTP("smtp.example.com")
    
    def create_user(self, email, password):
        self.logger.info(f"Creating user: {email}")
        cursor = self.db.cursor()
        cursor.execute("INSERT INTO users (email, password) VALUES (?, ?)",
                      (email, password))
        self.db.commit()
        
        self.mailer.sendmail(
            "system@example.com",
            email,
            "Welcome to our service!"
        )
```

**DI Solution:**
```python
@singleton()
class UserRepository:
    def __init__(self, db: IDatabase):
        self.db = db
    
    def create_user(self, email: str, password: str):
        self.db.execute(
            "INSERT INTO users (email, password) VALUES (?, ?)",
            (email, password)
        )

@singleton()
class EmailService:
    def __init__(self, smtp_config: Options[SmtpConfig]):
        self.config = smtp_config.value
    
    def send_welcome_email(self, email: str):
        # Email sending logic here
        pass

@singleton()
class UserService:
    def __init__(
        self,
        repository: UserRepository,
        email_service: EmailService,
        logger: ILogger
    ):
        self.repository = repository
        self.email_service = email_service
        self.logger = logger
    
    def create_user(self, email: str, password: str):
        self.logger.info(f"Creating user: {email}")
        self.repository.create_user(email, password)
        self.email_service.send_welcome_email(email)
```

#### Static Methods and Utility Classes

**Anti-Pattern:**
```python
class PaymentUtils:
    @staticmethod
    def calculate_tax(amount):
        return amount * 0.2
    
    @staticmethod
    def validate_credit_card(number):
        return len(number) == 16

class OrderProcessor:
    def process_payment(self, amount, card_number):
        if PaymentUtils.validate_credit_card(card_number):
            total = amount + PaymentUtils.calculate_tax(amount)
            # Process payment...
```

**DI Solution:**
```python
class ITaxCalculator(ABC):
    @abstractmethod
    def calculate_tax(self, amount: float) -> float:
        pass

class IPaymentValidator(ABC):
    @abstractmethod
    def validate_credit_card(self, number: str) -> bool:
        pass

@singleton()
class DefaultTaxCalculator(ITaxCalculator):
    def calculate_tax(self, amount: float) -> float:
        return amount * 0.2

@singleton()
class DefaultPaymentValidator(IPaymentValidator):
    def validate_credit_card(self, number: str) -> bool:
        return len(number) == 16

@singleton()
class OrderProcessor:
    def __init__(
        self,
        tax_calculator: ITaxCalculator,
        payment_validator: IPaymentValidator
    ):
        self.tax_calculator = tax_calculator
        self.payment_validator = payment_validator
    
    def process_payment(self, amount: float, card_number: str):
        if self.payment_validator.validate_credit_card(card_number):
            total = amount + self.tax_calculator.calculate_tax(amount)
            # Process payment...
```

**When to use:**
Apply these patterns when:
- You need to replace implementations for testing
- Your application configuration needs to change based on environment
- You want to avoid tight coupling between modules
- You need to manage complex object lifecycles
- You want to make dependencies explicit and traceable

---

## Design Tutorial: Building an Order Processing Application with WD-DI

In this tutorial, we'll build a small order processing application using WD-DI. This guide will demonstrate how to structure your application using dependency injection as the backbone of your architecture. By the end of this tutorial, you'll see how WD-DI helps you achieve separation of concerns, robust configuration management, and a modular, testable codebase.

---

## Table of Contents

1. [Introduction](#introduction)
2. [Application Overview](#application-overview)
3. [Project Structure](#project-structure)
4. [Architectural Layers and Design](#architectural-layers-and-design)
    - [Domain Layer](#domain-layer)
    - [Data Access Layer](#data-access-layer)
    - [Service Layer (Business Logic)](#service-layer-business-logic)
    - [Presentation Layer](#presentation-layer)
    - [Infrastructure Layer](#infrastructure-layer)
5. [Wiring It All Up with WD-DI](#wiring-it-all-up-with-wd-di)
6. [Running the Application](#running-the-application)
7. [Conclusion](#conclusion)

---

## 1. Introduction

Dependency injection is a cornerstone of modern software architecture. It enables you to build loosely coupled, maintainable, and testable systems by decoupling the creation of objects from their usage. In this tutorial, we'll use WD-DI to build an Order Processing application that demonstrates:

- **Separation of concerns** via layered architecture.
- **Interface-driven design** to allow for flexibility and easy testing.
- **Robust configuration management** using strongly-typed options.
- **Middleware pipelines** for cross-cutting concerns (optional extension).
- **Proper management of service lifetimes** (transient, singleton, and scoped).

---

## 2. Application Overview

Our sample application, **OrderProcessor**, will:

- Accept and process an order.
- Validate and save the order.
- Notify the user via email.
- Log key actions throughout the process.

---

## 3. Project Structure

For clarity, our project is organized as follows:

```
order_processor/
├── design_tutorial.md      # This tutorial file
├── main.py                 # Application entry point
├── domain/
│   ├── models.py           # Domain models (e.g., Order)
│   └── interfaces.py       # Domain interfaces (e.g., IOrderService)
├── data/
│   └── repository.py       # Data access implementation
├── services/
│   └── order_service.py    # Business logic implementation
├── presentation/
│   └── controller.py       # Application controller (simulated CLI)
└── infrastructure/
    ├── config.py           # Configuration classes
    └── logging_service.py  # Logging service implementation
```

---

## 4. Architectural Layers and Design

### Domain Layer

This layer defines your core business entities and contracts.

**File: `domain/models.py`**

```python
from dataclasses import dataclass

@dataclass
class Order:
    order_id: str
    item: str
    quantity: int
    price: float
```

**File: `domain/interfaces.py`**

```python
from abc import ABC, abstractmethod

class IOrderRepository(ABC):
    @abstractmethod
    def save_order(self, order):
        pass

class IOrderService(ABC):
    @abstractmethod
    def process_order(self, order):
        pass
```

---

### Data Access Layer

Handles persistence and data operations.

**File: `data/repository.py`**

```python
from domain.interfaces import IOrderRepository
from infrastructure.logging_service import Logger

class OrderRepository(IOrderRepository):
    def __init__(self, logger: Logger):
        self.logger = logger

    def save_order(self, order):
        self.logger.log(f"Order saved: {order.order_id}")
        # In a real application, implement database save logic here.
```

---

### Service Layer (Business Logic)

Encapsulates your core business rules.

**File: `services/order_service.py`**

```python
from domain.interfaces import IOrderService, IOrderRepository
from domain.models import Order
from infrastructure.logging_service import Logger

class OrderService(IOrderService):
    def __init__(self, repository: IOrderRepository, logger: Logger):
        self.repository = repository
        self.logger = logger

    def process_order(self, order: Order):
        self.logger.log(f"Processing order: {order.order_id}")
        # Business logic: validate order, process payment, etc.
        self.repository.save_order(order)
        self.logger.log(f"Order processed: {order.order_id}")
```

---

### Presentation Layer

Provides the interface to interact with your application (e.g., a CLI or web controller).

**File: `presentation/controller.py`**

```python
from domain.models import Order
from domain.interfaces import IOrderService

class OrderController:
    def __init__(self, order_service: IOrderService):
        self.order_service = order_service

    def submit_order(self, order_id, item, quantity, price):
        order = Order(order_id=order_id, item=item, quantity=quantity, price=price)
        self.order_service.process_order(order)
```

---

### Infrastructure Layer

Manages cross-cutting concerns like configuration and logging.

**File: `infrastructure/config.py`**

```python
from dataclasses import dataclass

@dataclass
class AppConfig:
    debug: bool = False
    email_server: str = ""
```

**File: `infrastructure/logging_service.py`**

```python
class Logger:
    def log(self, message: str):
        print(f"[LOG]: {message}")
```

---

## 5. Wiring It All Up with WD-DI

Now we'll integrate everything using WD-DI. The following code in `main.py` demonstrates how to register your services and build the application.

**File: `main.py`**

```python
from wd.di import services
from wd.di.config import Configuration, Options
from infrastructure.config import AppConfig
from infrastructure.logging_service import Logger
from data.repository import OrderRepository
from services.order_service import OrderService
from presentation.controller import OrderController

# Configure application settings
config = Configuration({
    "app": {
        "debug": True,
        "emailServer": "smtp.example.com"
    }
})
services.add_singleton_factory(IConfiguration, lambda _: config)
services.configure(AppConfig, section="app")

# Register infrastructure services
services.add_instance(Logger, Logger())

# Register data access layer (repository)
services.add_singleton(IOrderRepository, OrderRepository)

# Register business logic (order service)
services.add_singleton(IOrderService, OrderService)

# Register presentation layer (controller)
services.add_transient(OrderController)

# Build the service provider
provider = services.build_service_provider()

# Resolve the controller and simulate an order submission
controller = provider.get_service(OrderController)
controller.submit_order("order001", "Widget", 5, 19.99)
```

---

## 6. Running the Application

To run the application, execute the following command from your terminal:

```bash
python main.py
```

You should see log messages indicating each step of the order processing workflow, such as order submission, processing, and saving.

---

## 7. Conclusion

In this tutorial, we've built a simple order processing application that demonstrates how to:

- **Separate concerns** by splitting the application into distinct layers.
- **Design using interfaces** and concrete implementations to achieve a flexible, testable codebase.
- **Manage configuration** through strongly-typed options.
- **Leverage WD-DI** to wire all components together, ensuring proper management of service lifetimes and dependencies.

By using WD-DI, you not only simplify dependency management but also establish a solid foundation for building scalable and maintainable applications. This design tutorial shows that dependency injection is far more than a theoretical concept—it’s a practical tool for crafting high-quality software architectures.

```

---

### 3. docs\todo_until_feature_complete.md

- **File ID**: file_2
- **Type**: File
- **Line Count**: 230
- **Description**: File at docs\todo_until_feature_complete.md

**Content**:
```
Here's the updated todo list with the "Instance Registration" feature now marked as complete:

---

### Updated Todo List

#### 1. Dependency Injection Container Enhancements

- [x] **Scoped Services Resolution & Scope Management**  
  *Explicit scope creation and disposal management for scoped services have been implemented.*

- [x] **Circular Dependency Detection**  
  *Detection of circular dependencies during resolution (with proper error messages) is now in place.*

- [ ] **Open Generic Types Support:**  
  Add the ability to register and resolve open generic types for generic service definitions.

- [x] **Instance Registration:**  
  *The `add_instance` API for registering pre-instantiated services has been implemented.*

- [ ] **Multiple Implementations / Named Services:**  
  Support multiple registrations for a single service type and allow resolution as collections.

- [ ] **Improved Constructor Injection:**  
  Enhance dependency resolution to handle default parameter values and cases with missing or ambiguous type annotations.

- [ ] **Thread Safety Improvements:**  
  Review and enhance the container to be thread-safe in multi-threaded environments.

---

#### 2. Middleware Pipeline Enhancements

- [ ] **Exception Handling Integration:**  
  Integrate `ExceptionHandlerMiddleware` into the default pipeline configuration and add tests for graceful error handling.

- [ ] **Middleware Registration & Lifetime Management:**  
  Refine middleware registration to better manage middleware lifetimes and resolve dependencies within appropriate scopes.

- [ ] **Advanced Pipeline Configuration:**  
  Explore features like branching pipelines, conditional middleware execution, or pipeline termination.

---

#### 3. Options/Configuration Enhancements

- [ ] **Type Conversion and Validation:**  
  Improve the `OptionsBuilder` to support robust type conversion and integrate validation logic.

- [ ] **Dynamic Configuration Reloading:**  
  Optionally add support for reloading configuration when underlying sources (e.g., JSON or environment variables) change.

---

#### 4. Testing and Documentation

- [ ] **Expanded Test Coverage:**  
  Add tests for new and pending features (e.g., open generic types, multiple implementations).

- [ ] **Documentation and Code Comments:**  
  Enhance inline documentation, add usage examples, and update the README to guide users.

- [ ] **Refactor Global State:**  
  Consider isolating or refactoring the global `services` instance to reduce side effects in testing and production environments.

---

#### 5. Additional Features

- [ ] **Integration with Python Logging:**  
  Replace default print statements in logging middleware with integration into Python’s standard logging module.

- [ ] **Support for Async Service Factories:**  
  Investigate and add support for asynchronous factory methods for services requiring async initialization.

- [ ] **Dependency Injection Extensions:**  
  Create helper functions or decorators for common patterns (e.g., function injection, async injection) to extend the framework’s usability.

---

## Other ideas/Personal ideas

1. **Service Discovery and Assembly Scanning**
- Auto-registration of services based on decorators/attributes
- Scanning assemblies/modules for services marked for registration
- Convention-based registration (e.g., all classes ending with 'Service')

2. **Advanced Service Resolution**
```python
# Named/keyed services
services.add_singleton(IService, ServiceA, name="serviceA")
services.add_singleton(IService, ServiceB, name="serviceB")

# Enumerable resolution
@singleton()
class Processor:
    def __init__(self, handlers: List[IHandler]):  # Inject all IHandler implementations
        self.handlers = handlers

# Lazy resolution
@singleton()
class Service:
    def __init__(self, lazy_dep: Lazy[ExpensiveService]):
        self._dep = lazy_dep  # Only created when accessed
```

3. **Better Async Support**
```python
# Async service initialization
@singleton()
class AsyncService:
    @classmethod
    async def create(cls):
        # Async initialization logic
        return cls()

# Async disposal
@singleton()
class AsyncDisposable:
    async def dispose(self):
        # Async cleanup
        pass
```

4. **Enhanced Configuration**
```python
# Environment-specific configuration
config = (ConfigurationBuilder()
    .add_json_file("appsettings.json")
    .add_json_file(f"appsettings.{env}.json", optional=True)
    .add_env_variables()
    .build())

# Strongly-typed nested configuration
@dataclass
class DatabaseConfig:
    connection_string: str
    max_connections: int

@dataclass
class AppConfig:
    database: DatabaseConfig
    debug: bool
```

5. **Service Replacement and Decoration**
```python
# Replace existing registration
services.replace_singleton(IService, NewImplementation)

# Decorate existing service
services.decorate(IService, lambda service: LoggingDecorator(service))
```

6. **Enhanced Validation**
```python
# Validate service registration
services.validate()  # Check for missing dependencies, circular references

# Validate scoped service usage
services.validate_scopes()  # Ensure scoped services aren't used in singletons
```

7. **Service Factory Support**
```python
# Factory for creating services with runtime parameters
@singleton()
class UserService:
    def __init__(self, connection_factory: Callable[[str], Connection]):
        self.connection_factory = connection_factory

services.add_singleton_factory(
    Connection, 
    lambda sp, connection_string: create_connection(connection_string)
)
```

8. **Diagnostics and Debugging**
```python
# Service resolution visualization
services.print_dependency_graph()

# Resolution metrics
services.get_metrics()  # Service creation times, counts, etc.
```

9. **Middleware Enhancements**
```python
# Ordered middleware
services.use_middleware(AuthMiddleware, order=1)
services.use_middleware(LoggingMiddleware, order=2)

# Conditional middleware
services.use_middleware_if(DebugMiddleware, lambda context: context.is_debug)
```

10. **Scope Features**
```python
# Named scopes
with provider.create_scope("request") as scope:
    service = scope.get_service(MyService)

# Scope validation
services.validate_scope_boundaries()

# Scope events
scope.on_disposing(lambda: cleanup_resources())
```

11. **Extended Type Support**
```python
# Generic service support
services.add_singleton(Repository[User])
services.add_singleton(Repository[Order])

# Optional dependencies
def __init__(self, optional: Optional[IService] = None):
    self.service = optional
```

12. **Testing Utilities**
```python
# Mock service provider
mock_provider = MockServiceProvider()
mock_provider.setup(IService).returns(mock_service)

# Service collection snapshots
snapshot = services.create_snapshot()
# Make changes
services.restore_snapshot(snapshot)

```

---

### 4. examples\decorator_type_hints_example.py

- **File ID**: file_3
- **Type**: Code File
- **Line Count**: 72
- **Description**: File at examples\decorator_type_hints_example.py
- **Dependencies**: None
- **Used By**: None

**Content**:
```
from abc import ABC, abstractmethod
from dataclasses import dataclass
from wd.di import services
from wd.di.config import Configuration, IConfiguration
from wd.di.decorators import singleton

# Define interfaces
class IEmailService(ABC):
    @abstractmethod
    def send_email(self, to: str, subject: str, body: str) -> None:
        pass

class IUserService(ABC):
    @abstractmethod
    def notify_user(self, user_id: str, message: str) -> None:
        pass



config = Configuration({
    "app": {
        "api_key": "real-secret-key"
    }
})

@dataclass
class AppConfig:
    api_key: str = "secret-key"

services.add_singleton_factory(IConfiguration, lambda _: config)
services.configure(AppConfig, section="app")

# Implementations with decorators
@singleton(IEmailService)  # Type hint works with interface
class EmailService(IEmailService):
    def send_email(self, to: str, subject: str, body: str) -> None:
        print(f"Sending email to {to}")

@singleton(IUserService)  # Type hint works with interface
class UserService(IUserService):
    def __init__(self, email_service: IEmailService):  # Constructor injection with proper type
        self.email_service = email_service

    def notify_user(self, user_id: str, message: str) -> None:
        self.email_service.send_email(f"user{user_id}@example.com", "Notification", message)



# Service without interface - register directly with the class
class LogService:
    def log(self, message: str) -> None:
        print(f"[LOG] {message}")

# Register the concrete class
services.add_singleton(LogService)

# Build provider
provider = services.build_service_provider()

# Get services with proper type hints
log_service = provider.get_service(LogService)  # Type hints/code completion work for concrete class
email_service = provider.get_service(IEmailService)  # Type hints/code completion work for interface
user_service = provider.get_service(IUserService)   
configuration = provider.get_service(IConfiguration) 


# Use the services (IDE provides code completion for all methods)
log_service.log("Application started")
email_service.send_email("test@example.com", "Test", "Hello")
user_service.notify_user("123", "Welcome!")
config_value = configuration.get("app:api_key")
log_service.log(f"Got config: {config_value}")

```

---

### 5. examples\order_processor\data\repository.py

- **File ID**: file_4
- **Type**: Code File
- **Line Count**: 10
- **Description**: File at examples\order_processor\data\repository.py
- **Dependencies**: None
- **Used By**: None

**Content**:
```
from domain.interfaces import IOrderRepository
from infrastructure.logging_service import Logger

class OrderRepository(IOrderRepository):
    def __init__(self, logger: Logger):
        self.logger = logger

    def save_order(self, order):
        self.logger.log(f"Order saved: {order.order_id}")
        # In a real application, implement database save logic here.

```

---

### 6. examples\order_processor\domain\interfaces.py

- **File ID**: file_5
- **Type**: Code File
- **Line Count**: 11
- **Description**: File at examples\order_processor\domain\interfaces.py
- **Dependencies**: None
- **Used By**: None

**Content**:
```
from abc import ABC, abstractmethod

class IOrderRepository(ABC):
    @abstractmethod
    def save_order(self, order):
        pass

class IOrderService(ABC):
    @abstractmethod
    def process_order(self, order):
        pass
```

---

### 7. examples\order_processor\domain\models.py

- **File ID**: file_6
- **Type**: Code File
- **Line Count**: 8
- **Description**: File at examples\order_processor\domain\models.py
- **Dependencies**: None
- **Used By**: None

**Content**:
```
from dataclasses import dataclass

@dataclass
class Order:
    order_id: str
    item: str
    quantity: int
    price: float
```

---

### 8. examples\order_processor\infrastructure\config.py

- **File ID**: file_7
- **Type**: Code File
- **Line Count**: 6
- **Description**: File at examples\order_processor\infrastructure\config.py
- **Dependencies**: None
- **Used By**: None

**Content**:
```
from dataclasses import dataclass

@dataclass
class AppConfig:
    debug: bool = False
    email_server: str = ""
```

---

### 9. examples\order_processor\infrastructure\logging_service.py

- **File ID**: file_8
- **Type**: Code File
- **Line Count**: 3
- **Description**: File at examples\order_processor\infrastructure\logging_service.py
- **Dependencies**: None
- **Used By**: None

**Content**:
```
class Logger:
    def log(self, message: str):
        print(f"[LOG]: {message}")
```

---

### 10. examples\order_processor\main.py

- **File ID**: file_9
- **Type**: Code File
- **Line Count**: 37
- **Description**: File at examples\order_processor\main.py
- **Dependencies**: None
- **Used By**: None

**Content**:
```
from domain.interfaces import IOrderRepository, IOrderService
from wd.di import services
from wd.di.config import Configuration, IConfiguration
from infrastructure.config import AppConfig
from infrastructure.logging_service import Logger
from data.repository import OrderRepository
from services.order_service import OrderService
from presentation.controller import OrderController

# Configure application settings
config = Configuration({
    "app": {
        "debug": True,
        "emailServer": "smtp.example.com"
    }
})
services.add_singleton_factory(IConfiguration, lambda _: config)
services.configure(AppConfig, section="app")

# Register infrastructure services
services.add_instance(Logger, Logger())

# Register data access layer (repository)
services.add_singleton(IOrderRepository, OrderRepository)

# Register business logic (order service)
services.add_singleton(IOrderService, OrderService)

# Register presentation layer (controller)
services.add_transient(OrderController)

# Build the service provider
provider = services.build_service_provider()

# Resolve the controller and simulate an order submission
controller = provider.get_service(OrderController)
controller.submit_order("order001", "Widget", 5, 19.99)

```

---

### 11. examples\order_processor\presentation\controller.py

- **File ID**: file_10
- **Type**: Code File
- **Line Count**: 10
- **Description**: File at examples\order_processor\presentation\controller.py
- **Dependencies**: None
- **Used By**: None

**Content**:
```
from domain.models import Order
from domain.interfaces import IOrderService

class OrderController:
    def __init__(self, order_service: IOrderService):
        self.order_service = order_service

    def submit_order(self, order_id, item, quantity, price):
        order = Order(order_id=order_id, item=item, quantity=quantity, price=price)
        self.order_service.process_order(order)

```

---

### 12. examples\order_processor\services\order_service.py

- **File ID**: file_11
- **Type**: Code File
- **Line Count**: 14
- **Description**: File at examples\order_processor\services\order_service.py
- **Dependencies**: None
- **Used By**: None

**Content**:
```
from domain.interfaces import IOrderService, IOrderRepository
from domain.models import Order
from infrastructure.logging_service import Logger

class OrderService(IOrderService):
    def __init__(self, repository: IOrderRepository, logger: Logger):
        self.repository = repository
        self.logger = logger

    def process_order(self, order: Order):
        self.logger.log(f"Processing order: {order.order_id}")
        # Business logic: validate order, process payment, etc.
        self.repository.save_order(order)
        self.logger.log(f"Order processed: {order.order_id}")

```

---

### 13. examples\type_hints_example.py

- **File ID**: file_12
- **Type**: Code File
- **Line Count**: 34
- **Description**: File at examples\type_hints_example.py
- **Dependencies**: None
- **Used By**: None

**Content**:
```
from abc import ABC, abstractmethod
from wd.di import services

# Define interfaces and implementations
class IEmailService(ABC):
    @abstractmethod
    def send_email(self, to: str, subject: str, body: str) -> None:
        pass

class EmailService(IEmailService):
    def send_email(self, to: str, subject: str, body: str) -> None:
        print(f"Sending email to {to}")

class UserService:
    def __init__(self, email_service: IEmailService):
        self.email_service = email_service

    def notify_user(self, user_id: str, message: str) -> None:
        self.email_service.send_email(f"user{user_id}@example.com", "Notification", message)

# Register services
services.add_singleton(IEmailService, EmailService)
services.add_singleton(UserService)

# Build provider
provider = services.build_service_provider()

# Get services with proper type hints
email_service = provider.get_service(IEmailService)  # Type hints work here
user_service = provider.get_service(UserService)      # And here

# IDE will provide code completion for these methods
email_service.send_email("test@example.com", "Test", "Hello")
user_service.notify_user("123", "Welcome!")

```

---

### 14. src\wd\di\__init__.py

- **File ID**: file_13
- **Type**: Code File
- **Line Count**: 24
- **Description**: File at src\wd\di\__init__.py
- **Dependencies**: None
- **Used By**:
  - file_16

**Content**:
```
from importlib.metadata import PackageNotFoundError, version


from wd.di.service_collection import ServiceCollection
from wd.di.middleware import (
    IMiddleware,
    MiddlewarePipeline,
    LoggingMiddleware,
    ValidationMiddleware,
    CachingMiddleware,
    ExceptionHandlerMiddleware,
)
from wd.di.middleware_di import create_application_builder

try:
    __version__ = version("wd-di")
except PackageNotFoundError:
    __version__ = "0.1.1"


services = ServiceCollection()

# Attach extension methods
ServiceCollection.create_application_builder = create_application_builder

```

---

### 15. src\wd\di\config.py

- **File ID**: file_14
- **Type**: Code File
- **Line Count**: 116
- **Description**: File at src\wd\di\config.py
- **Dependencies**: None
- **Used By**:
  - file_21

**Content**:
```
from abc import ABC, abstractmethod
from typing import Any, Dict, Optional, TypeVar, Generic, Type
from dataclasses import dataclass
import json
import os

T = TypeVar("T")


class IConfiguration(ABC):
    @abstractmethod
    def get(self, key: str) -> Any:
        pass

    @abstractmethod
    def get_section(self, section: str) -> "IConfiguration":
        pass


class Configuration(IConfiguration):
    def __init__(self, data: Dict[str, Any]):
        self._data = data

    def get(self, key: str) -> Any:
        keys = key.split(":")
        current = self._data
        for k in keys:
            if not isinstance(current, dict) or k not in current:
                return None
            current = current[k]
        return current

    def get_section(self, section: str) -> "IConfiguration":
        value = self.get(section)
        if isinstance(value, dict):
            return Configuration(value)
        return Configuration({})


class ConfigurationBuilder:
    def __init__(self):
        self._sources: Dict[str, Any] = {}

    def add_json_file(self, path: str) -> "ConfigurationBuilder":
        if os.path.exists(path):
            with open(path, "r") as f:
                self._sources.update(json.load(f))
        return self

    def add_env_variables(self, prefix: str = "") -> "ConfigurationBuilder":
        for key, value in os.environ.items():
            if prefix and not key.startswith(prefix):
                continue
            if prefix:
                key = key[len(prefix) :]
            self._sources[key] = value
        return self

    def add_dictionary(self, dictionary: Dict[str, Any]) -> "ConfigurationBuilder":
        self._sources.update(dictionary)
        return self

    def build(self) -> IConfiguration:
        return Configuration(self._sources)


@dataclass
class ConfigureOptions:
    section: str


class Options(Generic[T]):
    def __init__(self, value: T):
        self._value = value

    @property
    def value(self) -> T:
        return self._value


class OptionsBuilder(Generic[T]):
    def __init__(self, options_type: Type[T]):
        self._options_type = options_type
        self._configuration: Optional[IConfiguration] = None
        self._section: Optional[str] = None

    def bind_configuration(
        self, configuration: IConfiguration, section: Optional[str] = None
    ) -> "OptionsBuilder[T]":
        self._configuration = configuration
        self._section = section
        return self

    def build(self) -> T:
        if self._configuration is None:
            return self._options_type()

        config_section = self._configuration
        if self._section:
            config_section = self._configuration.get_section(self._section)

        instance = self._options_type()
        config_dict = {}

        if hasattr(config_section, "_data"):
            config_dict = config_section._data

        # Convert camelCase to snake_case for property names
        for key, value in config_dict.items():
            snake_key = "".join(
                ["_" + c.lower() if c.isupper() else c for c in key]
            ).lstrip("_")
            if hasattr(instance, snake_key):
                setattr(instance, snake_key, value)

        return instance

```

---

### 16. src\wd\di\container.py

- **File ID**: file_15
- **Type**: Code File
- **Line Count**: 125
- **Description**: File at src\wd\di\container.py
- **Dependencies**:
  - file_17
  - file_18
- **Used By**:
  - file_21
  - file_17

**Content**:
```
from typing import Any, Dict, Type, Set, Optional, get_type_hints, TypeVar, Generic, overload

from .descriptors import ServiceDescriptor
from .lifetimes import ServiceLifetime

T = TypeVar('T')

class ServiceProvider:
    def __init__(self, services: Dict[Type, ServiceDescriptor]):
        self._services = services
        self._singletons = {}

    @overload
    def get_service(self, service_type: Type[T]) -> T: ...

    @overload
    def get_service(self, service_type: Type[T], resolving: Optional[Set[Type]] = None) -> T: ...

    def get_service(self, service_type: Type[T], resolving: Optional[Set[Type]] = None) -> T:
        if resolving is None:
            resolving = set()
        if service_type in resolving:
            raise Exception(f"Circular dependency detected for service: {service_type}")
        resolving.add(service_type)
        try:
            descriptor = self._services.get(service_type)
            if descriptor is None:
                raise Exception(f"Service {service_type} not registered.")

            if descriptor.lifetime == ServiceLifetime.SINGLETON:
                if descriptor.instance is None:
                    descriptor.instance = self._create_instance(descriptor, resolving)
                return descriptor.instance
            elif descriptor.lifetime == ServiceLifetime.TRANSIENT:
                return self._create_instance(descriptor, resolving)
            elif descriptor.lifetime == ServiceLifetime.SCOPED:
                raise Exception("Cannot resolve scoped service from the root provider. "
                                "Please create a scope using 'create_scope()' and resolve it from the scope.")
            else:
                raise Exception("Unknown service lifetime.")
        finally:
            resolving.remove(service_type)

    def create_scope(self) -> "Scope":
        return Scope(self._services, self)

    def _create_instance(self, descriptor: ServiceDescriptor, resolving: Set[Type]) -> Any:
        if descriptor.implementation_factory:
            return descriptor.implementation_factory(self)
        else:
            implementation_type = descriptor.implementation_type
            constructor = implementation_type.__init__
            try:
                param_types = get_type_hints(constructor)
            except NameError as e:
                # This catch-all assumes that a NameError during get_type_hints is due to a circular dependency
                # involving local forward references. Re-raise as a circular dependency error.
                raise Exception(f"Circular dependency detected for service: {implementation_type}") from e

            dependencies = {}
            for param, param_type in param_types.items():
                if param == "return":
                    continue
                dependencies[param] = self.get_service(param_type, resolving)
            return implementation_type(**dependencies)  # type: ignore


class Scope(ServiceProvider):
    def __init__(self, services: Dict[Type, ServiceDescriptor], parent_provider: ServiceProvider):
        super().__init__(services)
        self._parent_provider = parent_provider
        self._scoped_instances = {}
        self._disposables = []

    @overload
    def get_service(self, service_type: Type[T]) -> T: ...

    @overload
    def get_service(self, service_type: Type[T], resolving: Optional[Set[Type]] = None) -> T: ...

    def get_service(self, service_type: Type[T], resolving: Optional[Set[Type]] = None) -> T:
        if resolving is None:
            resolving = set()
        if service_type in resolving:
            raise Exception(f"Circular dependency detected for service: {service_type}")
        resolving.add(service_type)
        try:
            descriptor = self._services.get(service_type)
            if descriptor is None:
                raise Exception(f"Service {service_type} not registered.")

            if descriptor.lifetime == ServiceLifetime.SCOPED:
                if service_type not in self._scoped_instances:
                    instance = self._create_instance(descriptor, resolving)
                    self._scoped_instances[service_type] = instance
                    if hasattr(instance, "dispose") and callable(instance.dispose):
                        self._disposables.append(instance)
                    elif hasattr(instance, "close") and callable(instance.close):
                        self._disposables.append(instance)
                return self._scoped_instances[service_type]
            else:
                return super().get_service(service_type, resolving)
        finally:
            resolving.remove(service_type)

    def dispose(self):
        for instance in self._disposables:
            if hasattr(instance, "dispose") and callable(instance.dispose):
                try:
                    instance.dispose()
                except Exception as e:
                    print(f"Error disposing {instance}: {e}")
            elif hasattr(instance, "close") and callable(instance.close):
                try:
                    instance.close()
                except Exception as e:
                    print(f"Error closing {instance}: {e}")
        self._disposables.clear()
        self._scoped_instances.clear()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.dispose()

```

---

### 17. src\wd\di\decorators.py

- **File ID**: file_16
- **Type**: Code File
- **Line Count**: 54
- **Description**: File at src\wd\di\decorators.py
- **Dependencies**:
  - file_13
- **Used By**: None

**Content**:
```
from typing import TypeVar, Type, Optional, Callable, cast, overload

from . import services

T = TypeVar('T')
S = TypeVar('S')

@overload
def transient() -> Callable[[Type[T]], Type[T]]: ...

@overload
def transient(service_type: Type[S]) -> Callable[[Type[T]], Type[T]]: ...

def transient(service_type: Optional[Type[S]] = None) -> Callable[[Type[T]], Type[T]]:
    def decorator(implementation_type: Type[T]) -> Type[T]:
        if service_type is None:
            # When no interface is provided, register the implementation type as both service and implementation
            services.add_transient(implementation_type, implementation_type)
        else:
            services.add_transient(service_type, implementation_type)
        return implementation_type
    return decorator

@overload
def singleton() -> Callable[[Type[T]], Type[T]]: ...

@overload
def singleton(service_type: Type[S]) -> Callable[[Type[T]], Type[T]]: ...

def singleton(service_type: Optional[Type[S]] = None) -> Callable[[Type[T]], Type[T]]:
    def decorator(implementation_type: Type[T]) -> Type[T]:
        if service_type is None:
            # When no interface is provided, register the implementation type as both service and implementation
            services.add_singleton(implementation_type, implementation_type)
        else:
            services.add_singleton(service_type, implementation_type)
        return implementation_type
    return decorator

@overload
def scoped() -> Callable[[Type[T]], Type[T]]: ...

@overload
def scoped(service_type: Type[S]) -> Callable[[Type[T]], Type[T]]: ...

def scoped(service_type: Optional[Type[S]] = None) -> Callable[[Type[T]], Type[T]]:
    def decorator(implementation_type: Type[T]) -> Type[T]:
        if service_type is None:
            # When no interface is provided, register the implementation type as both service and implementation
            services.add_scoped(implementation_type, implementation_type)
        else:
            services.add_scoped(service_type, implementation_type)
        return implementation_type
    return decorator

```

---

### 18. src\wd\di\descriptors.py

- **File ID**: file_17
- **Type**: Code File
- **Line Count**: 21
- **Description**: File at src\wd\di\descriptors.py
- **Dependencies**:
  - file_15
  - file_18
- **Used By**:
  - file_21
  - file_15

**Content**:
```
from typing import Any, Callable, Optional, Type, TYPE_CHECKING

from .lifetimes import ServiceLifetime

if TYPE_CHECKING:
    from .container import ServiceProvider


class ServiceDescriptor:
    def __init__(
        self,
        service_type: Type,
        implementation_type: Optional[Type] = None,
        implementation_factory: Optional[Callable[["ServiceProvider"], Any]] = None,
        lifetime: ServiceLifetime = ServiceLifetime.TRANSIENT,
    ):
        self.service_type = service_type
        self.implementation_type = implementation_type
        self.implementation_factory = implementation_factory
        self.lifetime = lifetime
        self.instance = None  # For singleton

```

---

### 19. src\wd\di\lifetimes.py

- **File ID**: file_18
- **Type**: Code File
- **Line Count**: 7
- **Description**: File at src\wd\di\lifetimes.py
- **Dependencies**: None
- **Used By**:
  - file_21
  - file_17
  - file_15

**Content**:
```
from enum import Enum


class ServiceLifetime(Enum):
    TRANSIENT = 1
    SINGLETON = 2
    SCOPED = 3

```

---

### 20. src\wd\di\middleware.py

- **File ID**: file_19
- **Type**: Code File
- **Line Count**: 119
- **Description**: File at src\wd\di\middleware.py
- **Dependencies**: None
- **Used By**:
  - file_20

**Content**:
```
from abc import ABC, abstractmethod
from typing import Any, Callable, List, Optional, TypeVar

T = TypeVar("T")
TNext = Callable[[], Any]
TMiddleware = Callable[[T, TNext], Any]


class IMiddleware(ABC):
    """Base interface for middleware components."""

    @abstractmethod
    async def invoke(self, context: T, next: TNext) -> Any:
        """Process the context and call the next middleware in the pipeline."""
        pass


class MiddlewarePipeline:
    """Manages the middleware pipeline execution."""

    def __init__(self):
        self._middleware: List[TMiddleware[T]] = []

    def use(self, middleware: TMiddleware[T]) -> "MiddlewarePipeline":
        """Add a middleware to the pipeline."""
        self._middleware.append(middleware)
        return self

    def use_middleware(
        self, middleware_class: type, instance: Optional[Any] = None
    ) -> "MiddlewarePipeline":
        """Add a middleware class to the pipeline."""

        def adapter(context: T, next: TNext) -> Any:
            nonlocal instance
            if instance is None:
                instance = middleware_class()
            return instance.invoke(context, next)

        self._middleware.append(adapter)
        return self

    async def execute(self, context: T) -> Any:
        """Execute the middleware pipeline."""
        if not self._middleware:
            return None

        index = 0

        async def invoke_next() -> Any:
            nonlocal index
            if index < len(self._middleware):
                middleware = self._middleware[index]
                index += 1
                return await middleware(context, invoke_next)
            return None

        return await invoke_next()


class ExceptionHandlerMiddleware(IMiddleware):
    """Built-in middleware for handling exceptions in the pipeline."""

    async def invoke(self, context: T, next: TNext) -> Any:
        try:
            return await next()
        except Exception as e:
            # Log the exception or handle it as needed
            raise


class LoggingMiddleware(IMiddleware):
    """Built-in middleware for logging pipeline execution."""

    def __init__(self, logger: Optional[Callable[[str], None]] = None):
        self._logger = logger or print

    async def invoke(self, context: T, next: TNext) -> Any:
        self._logger(f"Executing pipeline with context: {context}")
        try:
            result = await next()
            self._logger(f"Pipeline execution completed with result: {result}")
            return result
        except Exception as e:
            self._logger(f"Pipeline execution failed: {str(e)}")
            raise


class ValidationMiddleware(IMiddleware):
    """Built-in middleware for context validation."""

    def __init__(self, validator: Callable[[T], bool]):
        self._validator = validator

    async def invoke(self, context: T, next: TNext) -> Any:
        if not self._validator(context):
            raise ValueError(f"Invalid context: {context}")
        return await next()


class CachingMiddleware(IMiddleware):
    """Built-in middleware for caching pipeline results."""

    def __init__(self):
        self._cache = {}

    async def invoke(self, context: T, next: TNext) -> Any:
        # Use context as cache key if it's hashable
        try:
            cache_key = hash(str(context.__dict__))
            if cache_key in self._cache:
                return self._cache[cache_key]

            result = await next()
            self._cache[cache_key] = result
            return result
        except (TypeError, AttributeError):
            # If context is not hashable or has no __dict__, skip caching
            return await next()

```

---

### 21. src\wd\di\middleware_di.py

- **File ID**: file_20
- **Type**: Code File
- **Line Count**: 76
- **Description**: File at src\wd\di\middleware_di.py
- **Dependencies**:
  - file_19
  - file_21
- **Used By**: None

**Content**:
```
from typing import Any, Callable, Optional, TypeVar
from .middleware import IMiddleware, MiddlewarePipeline, LoggingMiddleware
from .service_collection import ServiceCollection

T = TypeVar("T")


class MiddlewareBuilder:
    """Builder for configuring middleware in the DI container."""

    def __init__(self, services: ServiceCollection):
        self._services = services
        self._pipeline = MiddlewarePipeline()

    def use(
        self, middleware: Callable[[T, Callable[[], Any]], Any]
    ) -> "MiddlewareBuilder":
        """Add a middleware function to the pipeline."""
        self._pipeline.use(middleware)
        return self

    def use_middleware(self, middleware_type: type) -> "MiddlewareBuilder":
        """Add a middleware class to the pipeline."""
        # Register the middleware type with DI
        if middleware_type == LoggingMiddleware:
            # Special handling for LoggingMiddleware to provide default logger
            self._services.add_transient_factory(
                middleware_type, lambda _: LoggingMiddleware()
            )
        else:
            self._services.add_transient(middleware_type)

        # Create factory to resolve middleware instance from DI
        def create_middleware():
            provider = self._services.build_service_provider()
            return provider.get_service(middleware_type)

        self._pipeline.use_middleware(middleware_type, instance=create_middleware())
        return self

    def build(self) -> MiddlewarePipeline:
        """Build the middleware pipeline."""
        return self._pipeline


class ApplicationBuilder:
    """Builder for configuring the application with middleware support."""

    def __init__(self, services: ServiceCollection):
        self._services = services

    def configure_middleware(
        self, configure: Callable[["MiddlewareBuilder"], None]
    ) -> "ApplicationBuilder":
        """Configure the middleware pipeline."""
        builder = MiddlewareBuilder(self._services)
        configure(builder)
        pipeline = builder.build()

        # Register the pipeline as a singleton
        self._services.add_singleton_factory(MiddlewarePipeline, lambda _: pipeline)
        return self

    def build(self):
        """Build the application."""
        return self._services.build_service_provider()


# Extension methods for ServiceCollection
def create_application_builder(services: ServiceCollection) -> ApplicationBuilder:
    """Create an application builder for the service collection."""
    return ApplicationBuilder(services)


# Attach the extension method to ServiceCollection
ServiceCollection.create_application_builder = create_application_builder

```

---

### 22. src\wd\di\service_collection.py

- **File ID**: file_21
- **Type**: Code File
- **Line Count**: 108
- **Description**: File at src\wd\di\service_collection.py
- **Dependencies**:
  - file_15
  - file_17
  - file_18
  - file_14
- **Used By**:
  - file_20

**Content**:
```
# di_container/service_collection.py

from typing import Any, Callable, Dict, Optional, Type, TypeVar, TYPE_CHECKING, Generic

from .descriptors import ServiceDescriptor
from .lifetimes import ServiceLifetime
from .config import IConfiguration, Options, OptionsBuilder

if TYPE_CHECKING:
    from .container import ServiceProvider


T = TypeVar("T")


class ServiceCollection:
    def __init__(self):
        self._services: Dict[Type, ServiceDescriptor] = {}

    def add_transient_factory(
        self, service_type: Type, factory: Callable[["ServiceProvider"], Any]
    ):
        descriptor = ServiceDescriptor(
            service_type,
            implementation_factory=factory,
            lifetime=ServiceLifetime.TRANSIENT,
        )
        self._services[service_type] = descriptor

    def add_singleton_factory(
        self, service_type: Type, factory: Callable[["ServiceProvider"], Any]
    ):
        descriptor = ServiceDescriptor(
            service_type,
            implementation_factory=factory,
            lifetime=ServiceLifetime.SINGLETON,
        )
        self._services[service_type] = descriptor

    def transient(self, implementation_type: Type):
        self.add_transient(implementation_type)
        return implementation_type

    def singleton(self, implementation_type: Type):
        self.add_singleton(implementation_type)
        return implementation_type

    def scoped(self, implementation_type: Type):
        self.add_scoped(implementation_type)
        return implementation_type

    def add_transient(
        self, service_type: Type, implementation_type: Optional[Type] = None
    ):
        self._add_service(service_type, implementation_type, ServiceLifetime.TRANSIENT)

    def add_singleton(
        self, service_type: Type, implementation_type: Optional[Type] = None
    ):
        self._add_service(service_type, implementation_type, ServiceLifetime.SINGLETON)

    def add_scoped(
        self, service_type: Type, implementation_type: Optional[Type] = None
    ):
        self._add_service(service_type, implementation_type, ServiceLifetime.SCOPED)

    def _add_service(
        self,
        service_type: Type,
        implementation_type: Optional[Type],
        lifetime: ServiceLifetime,
    ):
        if implementation_type is None:
            implementation_type = service_type
        descriptor = ServiceDescriptor(
            service_type, implementation_type, None, lifetime
        )
        self._services[service_type] = descriptor

    def build_service_provider(self):
        from .container import ServiceProvider

        return ServiceProvider(self._services)
    
    def add_instance(self, service_type: Type, instance: Any):
        """
        Register an already constructed instance as a singleton service.
        This instance will be returned whenever service_type is requested.
        """
        descriptor = ServiceDescriptor(service_type, lifetime=ServiceLifetime.SINGLETON)
        descriptor.instance = instance
        self._services[service_type] = descriptor

    def configure(
        self, options_type: Type[T], *, section: Optional[str] = None
    ) -> None:
        """Configure options binding from configuration."""

        def factory(sp: "ServiceProvider") -> Options[T]:
            try:
                configuration = sp.get_service(IConfiguration)
                builder = OptionsBuilder(options_type)
                builder.bind_configuration(configuration, section)
                return Options(builder.build())
            except Exception as e:
                raise Exception("Configuration service not registered") from e

        self.add_singleton_factory(Options[options_type], factory)  # type: ignore

```

---

### 23. tests\__init__.py

- **File ID**: file_22
- **Type**: Code File
- **Line Count**: 1
- **Description**: File at tests\__init__.py
- **Dependencies**: None
- **Used By**: None

**Content**:
```


```

---

### 24. tests\test_circular_dependency.py

- **File ID**: file_23
- **Type**: Code File
- **Line Count**: 21
- **Description**: File at tests\test_circular_dependency.py
- **Dependencies**: None
- **Used By**: None

**Content**:
```
import pytest
from wd.di.service_collection import ServiceCollection

def test_circular_dependency_detection():
    # Define two classes that depend on each other
    class ServiceA:
        def __init__(self, service_b: "ServiceB"):
            self.service_b = service_b

    class ServiceB:
        def __init__(self, service_a: ServiceA):
            self.service_a = service_a

    services = ServiceCollection()
    services.add_transient(ServiceA)
    services.add_transient(ServiceB)

    provider = services.build_service_provider()

    with pytest.raises(Exception, match="Circular dependency detected"):
        provider.get_service(ServiceA)

```

---

### 25. tests\test_config.py

- **File ID**: file_24
- **Type**: Code File
- **Line Count**: 144
- **Description**: File at tests\test_config.py
- **Dependencies**: None
- **Used By**: None

**Content**:
```
import pytest
from dataclasses import dataclass
from wd.di.config import (
    Configuration,
    ConfigurationBuilder,
    Options,
    OptionsBuilder,
    IConfiguration,
)
from wd.di import services


@dataclass
class DatabaseOptions:
    connection_string: str = ""
    max_connections: int = 10


@dataclass
class AppSettings:
    name: str = ""
    version: str = ""


def test_configuration_get():
    config = Configuration(
        {
            "database": {
                "connectionString": "test-connection",
                "maxConnections": 5,
            },
            "app": {"name": "TestApp", "version": "1.0.0"},
        }
    )

    assert config.get("database:connectionString") == "test-connection"
    assert config.get("app:name") == "TestApp"
    assert config.get("nonexistent") is None
    assert config.get("database:nonexistent") is None


def test_configuration_get_section():
    config = Configuration(
        {
            "database": {
                "connectionString": "test-connection",
                "maxConnections": 5,
            }
        }
    )

    section = config.get_section("database")
    assert section.get("connectionString") == "test-connection"
    assert section.get("maxConnections") == 5


def test_configuration_builder():
    builder = ConfigurationBuilder()
    config = (
        builder.add_dictionary(
            {
                "database": {
                    "connectionString": "test-connection",
                    "maxConnections": 5,
                }
            }
        )
        .add_dictionary({"app": {"name": "TestApp"}})
        .build()
    )

    assert config.get("database:connectionString") == "test-connection"
    assert config.get("app:name") == "TestApp"


def test_options_builder():
    config = Configuration(
        {"database": {"connectionString": "test-connection", "maxConnections": 5}}
    )

    builder = OptionsBuilder(DatabaseOptions)
    options = builder.bind_configuration(config, "database").build()

    assert options.connection_string == "test-connection"
    assert options.max_connections == 5


def test_options_di_integration():
    # Reset services
    services._services.clear()

    # Setup configuration
    config = Configuration(
        {
            "database": {"connectionString": "test-connection", "maxConnections": 5},
            "app": {"name": "TestApp", "version": "1.0.0"},
        }
    )

    # Register services
    services.add_singleton_factory(IConfiguration, lambda sp: config)
    services.configure(DatabaseOptions, section="database")
    services.configure(AppSettings, section="app")

    # Build service provider
    provider = services.build_service_provider()

    # Resolve options
    db_options = provider.get_service(Options[DatabaseOptions])
    app_options = provider.get_service(Options[AppSettings])

    # Assert
    assert db_options.value.connection_string == "test-connection"
    assert db_options.value.max_connections == 5
    assert app_options.value.name == "TestApp"
    assert app_options.value.version == "1.0.0"


def test_options_without_configuration():
    # Reset services
    services._services.clear()

    # Configure options without providing configuration
    services.configure(DatabaseOptions)
    provider = services.build_service_provider()

    # Should raise an exception when configuration service is not registered
    with pytest.raises(Exception, match="Configuration service not registered"):
        provider.get_service(Options[DatabaseOptions])


def test_options_missing_section():
    # Reset services
    services._services.clear()

    config = Configuration({})
    services.add_singleton_factory(IConfiguration, lambda sp: config)
    services.configure(DatabaseOptions, section="database")
    provider = services.build_service_provider()

    # Should return default values when section is missing
    db_options = provider.get_service(Options[DatabaseOptions])
    assert db_options.value.connection_string == ""
    assert db_options.value.max_connections == 10

```

---

### 26. tests\test_decorators.py

- **File ID**: file_25
- **Type**: Code File
- **Line Count**: 31
- **Description**: File at tests\test_decorators.py
- **Dependencies**: None
- **Used By**: None

**Content**:
```
from wd.di.decorators import singleton, transient
from wd.di.service_collection import ServiceCollection


@transient()
class FooService:
    def do_something(self):
        print("FooService doing something!")


@singleton()
class BarService:
    def __init__(self, foo_service: FooService):
        self.foo_service = foo_service

    def do_something_else(self):
        print("BarService doing something else!")
        self.foo_service.do_something()


def test_decorators():
    services = ServiceCollection()
    # Register the services
    services.add_transient(FooService)
    services.add_singleton(BarService)
    
    service_provider = services.build_service_provider()
    bar_service = service_provider.get_service(BarService)
    bar_service.do_something_else()

    assert bar_service is not None

```

---

### 27. tests\test_di.py

- **File ID**: file_26
- **Type**: Code File
- **Line Count**: 52
- **Description**: File at tests\test_di.py
- **Dependencies**: None
- **Used By**: None

**Content**:
```
# tests/test_di.py

from typing import assert_type
from wd.di.service_collection import ServiceCollection


# Define test services
class IService:
    def execute(self):
        pass


class ServiceA(IService):
    def execute(self):
        return "ServiceA"


class ServiceB(IService):
    def __init__(self, service_a: ServiceA):
        self.service_a = service_a

    def execute(self):
        return f"ServiceB depends on {self.service_a.execute()}"


def test_transient_services():
    services = ServiceCollection()
    services.add_transient(ServiceA)
    services.add_transient(IService, ServiceB)

    provider = services.build_service_provider()
    service1 = provider.get_service(IService)
    service2 = provider.get_service(IService)

    assert service1 is not service2
    assert service1.execute() == "ServiceB depends on ServiceA"


def test_singleton_services():
    services = ServiceCollection()
    services.add_singleton(ServiceA)
    services.add_singleton(IService, ServiceB)

    provider = services.build_service_provider()
    service1 = provider.get_service(IService)
    service2 = provider.get_service(IService)


    assert_type(service1, IService)
    assert service1 is service2
    assert isinstance(service1, IService) and isinstance(service1, ServiceB)
    assert isinstance(service1, IService) and not isinstance(service1, ServiceA)
```

---

### 28. tests\test_middleware.py

- **File ID**: file_27
- **Type**: Code File
- **Line Count**: 218
- **Description**: File at tests\test_middleware.py
- **Dependencies**: None
- **Used By**: None

**Content**:
```
import pytest
from dataclasses import dataclass
from typing import List, Optional
from wd.di.middleware import (
    IMiddleware,
    MiddlewarePipeline,
    LoggingMiddleware,
    ValidationMiddleware,
    CachingMiddleware,
)
from wd.di import services


@dataclass
class RequestContext:
    path: str
    value: Optional[str] = None


class TestMiddleware(IMiddleware):
    def __init__(self):
        self.executed = False
        self.context_path = None

    async def invoke(self, context: RequestContext, next):
        self.executed = True
        self.context_path = context.path
        return await next()


class ModifyingMiddleware(IMiddleware):
    async def invoke(self, context: RequestContext, next):
        context.value = "modified"
        return await next()


class ResultMiddleware(IMiddleware):
    async def invoke(self, context: RequestContext, next):
        await next()
        return "result"


@pytest.mark.asyncio
async def test_middleware_pipeline_execution():
    pipeline = MiddlewarePipeline()
    middleware = TestMiddleware()
    pipeline.use_middleware(TestMiddleware, instance=middleware)

    context = RequestContext(path="/test")
    await pipeline.execute(context)

    assert middleware.executed
    assert middleware.context_path == "/test"


@pytest.mark.asyncio
async def test_middleware_order():
    executed_order: List[str] = []

    class FirstMiddleware(IMiddleware):
        async def invoke(self, context, next):
            executed_order.append("first")
            return await next()

    class SecondMiddleware(IMiddleware):
        async def invoke(self, context, next):
            executed_order.append("second")
            return await next()

    pipeline = MiddlewarePipeline()
    pipeline.use_middleware(FirstMiddleware)
    pipeline.use_middleware(SecondMiddleware)

    await pipeline.execute(RequestContext(path="/test"))
    assert executed_order == ["first", "second"]


@pytest.mark.asyncio
async def test_middleware_modification():
    pipeline = MiddlewarePipeline()
    pipeline.use_middleware(ModifyingMiddleware)

    context = RequestContext(path="/test")
    await pipeline.execute(context)

    assert context.value == "modified"


@pytest.mark.asyncio
async def test_middleware_result():
    pipeline = MiddlewarePipeline()
    pipeline.use_middleware(ResultMiddleware)

    result = await pipeline.execute(RequestContext(path="/test"))
    assert result == "result"


@pytest.mark.asyncio
async def test_validation_middleware():
    def validator(context: RequestContext) -> bool:
        return context.path.startswith("/")

    pipeline = MiddlewarePipeline()
    pipeline.use_middleware(lambda: ValidationMiddleware(validator))

    # Valid path should work
    await pipeline.execute(RequestContext(path="/test"))

    # Invalid path should raise ValueError
    with pytest.raises(ValueError):
        await pipeline.execute(RequestContext(path="invalid"))


@pytest.mark.asyncio
async def test_caching_middleware():
    executed_count = 0

    class CountingMiddleware(IMiddleware):
        async def invoke(self, context, next):
            nonlocal executed_count
            executed_count += 1
            return "result"

    pipeline = MiddlewarePipeline()
    pipeline.use_middleware(CachingMiddleware)
    pipeline.use_middleware(CountingMiddleware)

    context = RequestContext(path="/test")

    # First call should execute the pipeline
    result1 = await pipeline.execute(context)
    assert result1 == "result"
    assert executed_count == 1

    # Second call should use cached result
    result2 = await pipeline.execute(context)
    assert result2 == "result"
    assert executed_count == 1  # Count shouldn't increase


@pytest.mark.asyncio
async def test_logging_middleware():
    logs = []
    logger = lambda msg: logs.append(msg)

    pipeline = MiddlewarePipeline()
    pipeline.use_middleware(lambda: LoggingMiddleware(logger))
    pipeline.use_middleware(ResultMiddleware)

    await pipeline.execute(RequestContext(path="/test"))

    assert len(logs) == 2
    assert "Executing pipeline" in logs[0]
    assert "completed with result" in logs[1]


@pytest.mark.asyncio
async def test_di_integration():
    # Reset services
    services._services.clear()

    # Create application builder
    app = services.create_application_builder()

    # Configure middleware
    app.configure_middleware(
        lambda builder: (
            builder.use_middleware(LoggingMiddleware)
            .use_middleware(TestMiddleware)
            .use_middleware(ResultMiddleware)
        )
    )

    # Build provider
    provider = app.build()

    # Get pipeline from DI
    pipeline = provider.get_service(MiddlewarePipeline)

    # Execute pipeline
    result = await pipeline.execute(RequestContext(path="/test"))

    assert result == "result"


@pytest.mark.asyncio
async def test_di_middleware_dependencies():
    # Reset services
    services._services.clear()

    class DependentMiddleware(IMiddleware):
        def __init__(self, test_middleware: TestMiddleware):
            self.test_middleware = test_middleware

        async def invoke(self, context, next):
            await self.test_middleware.invoke(context, next)
            return "dependent_result"

    # Create application builder
    app = services.create_application_builder()

    # Configure middleware with dependencies
    app.configure_middleware(
        lambda builder: (
            builder.use_middleware(TestMiddleware).use_middleware(DependentMiddleware)
        )
    )

    # Build provider
    provider = app.build()

    # Get pipeline from DI
    pipeline = provider.get_service(MiddlewarePipeline)

    # Execute pipeline
    result = await pipeline.execute(RequestContext(path="/test"))

    assert result == "dependent_result"

```

---

### 29. tests\test_scoped.py

- **File ID**: file_28
- **Type**: Code File
- **Line Count**: 90
- **Description**: File at tests\test_scoped.py
- **Dependencies**: None
- **Used By**: None

**Content**:
```
import pytest
from wd.di.service_collection import ServiceCollection

def test_scoped_service_from_root_fails():
    # Define a simple scoped service.
    class ScopedService:
        pass

    services = ServiceCollection()
    services.add_scoped(ScopedService)
    provider = services.build_service_provider()

    # Attempting to resolve a scoped service directly from the root provider should fail.
    with pytest.raises(Exception, match="Cannot resolve scoped service from the root provider"):
        provider.get_service(ScopedService)

def test_scoped_service_same_instance_in_scope():
    # Define a simple scoped service.
    class ScopedService:
        pass

    services = ServiceCollection()
    services.add_scoped(ScopedService)
    provider = services.build_service_provider()

    # Within the same scope, multiple resolutions should yield the same instance.
    with provider.create_scope() as scope:
        instance1 = scope.get_service(ScopedService)
        instance2 = scope.get_service(ScopedService)
        assert instance1 is instance2

def test_scoped_service_different_instances_in_different_scopes():
    # Define a simple scoped service.
    class ScopedService:
        pass

    services = ServiceCollection()
    services.add_scoped(ScopedService)
    provider = services.build_service_provider()

    # Different scopes should produce different instances.
    with provider.create_scope() as scope1:
        instance1 = scope1.get_service(ScopedService)
    with provider.create_scope() as scope2:
        instance2 = scope2.get_service(ScopedService)
    assert instance1 is not instance2

def test_disposable_service_is_disposed():
    # Define a disposable service that implements a dispose method.
    class DisposableService:
        def __init__(self):
            self.is_disposed = False

        def dispose(self):
            self.is_disposed = True

    services = ServiceCollection()
    services.add_scoped(DisposableService)
    provider = services.build_service_provider()
    disposable_instance = None

    # Within the scope, the instance is not disposed.
    with provider.create_scope() as scope:
        disposable_instance = scope.get_service(DisposableService)
        assert not disposable_instance.is_disposed

    # Exiting the scope should trigger disposal.
    assert disposable_instance.is_disposed

def test_close_method_is_called_for_disposable():
    # Define a disposable service that uses a close method.
    class DisposableService:
        def __init__(self):
            self.is_closed = False

        def close(self):
            self.is_closed = True

    services = ServiceCollection()
    services.add_scoped(DisposableService)
    provider = services.build_service_provider()
    disposable_instance = None

    # Within the scope, the instance is not closed.
    with provider.create_scope() as scope:
        disposable_instance = scope.get_service(DisposableService)
        assert not disposable_instance.is_closed

    # Exiting the scope should trigger the close method.
    assert disposable_instance.is_closed

```

---

## Summary

- **Total Files**: 29
- **Code Files**: 26
- **Regular Files**: 3
- **Total Lines of Code**: 2942
